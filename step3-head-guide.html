<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Step 3 — Head Guide (Vanilla Canvas with Override + Save)</title>
<style>
  body{margin:0;background:#0e0f12;color:#e9eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  main{max-width:900px;margin:0 auto;padding:16px}
  h1{margin:8px 0 12px;font-size:18px}
  .row{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  @media(max-width:900px){.row{grid-template-columns:1fr}}
  canvas{
    display:block;width:100%;max-width:720px;height:auto;
    background:#0f1219;border:1px solid rgba(255,255,255,.12);border-radius:12px;
    touch-action:none;-ms-touch-action:none;
  }
  .panel{background:#151821;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px}
  .muted{color:#9aa3b2}
  button,input[type="range"],input[type="color"],input[type="checkbox"],input[type="file"]{
    appearance:none;background:#1a1f2b;color:#e9eef7;border:1px solid rgba(255,255,255,.12);
    padding:8px 10px;border-radius:10px;margin-right:8px
  }
  label{display:inline-flex;align-items:center;gap:8px}
  .ok{color:#5eead4}.warn{color:#fca5a5}
</style>
</head>
<body>
<main>
  <h1>Step 3 — Head Guide (Vanilla Canvas with Override + Save)</h1>
  <p class="muted">
    Base guide <code>assets/guides/head.png</code> loads by default. Uploading a file overrides it.
    “Remove guide” reverts to the base. Toggle “Show guide” to hide/show.
    <br>Use <b>Save Part</b> to export your drawing (no guide) as a transparent PNG and store it locally.
  </p>

  <div class="row">
    <div class="panel">
      <canvas id="c" width="720" height="720"></canvas>
      <div style="margin-top:10px;display:flex;flex-wrap:wrap;gap:8px">
        <label>Brush <input id="w" type="range" min="1" max="40" value="8"></label>
        <label>Opacity <input id="o" type="range" min="10" max="100" value="100"></label>
        <label>Color <input id="col" type="color" value="#60a5fa"></label>
        <label><input id="show" type="checkbox" checked> Show guide</label>
        <input id="upload" type="file" accept="image/*">
        <button id="remove">Remove guide</button>
        <button id="clear">Clear</button>
        <button id="save">Save Part</button>
      </div>
    </div>

    <div class="panel">
      <p id="status" class="muted">Status: loading base guide…</p>
      <p class="muted">Base path: <code>assets/guides/head.png</code></p>
      <ul class="muted">
        <li>Draw lines, lift finger/mouse — strokes should remain.</li>
        <li>Upload a PNG/JPG to override the base guide; “Remove guide” reverts to base.</li>
        <li><b>Save Part</b> downloads <code>head-part.png</code> (no guide) and stores it in localStorage.</li>
      </ul>
    </div>
  </div>
</main>

<script>
/* ------- Config ------- */
const baseGuidePath = 'assets/guides/head.png';
const STORE_KEY = 'vbgame.characterArt.v1'; // overall store
const PART_ID = 'head';                      // this page is for head only

/* ------- State ------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');

const showEl = document.getElementById('show');
const uploadEl = document.getElementById('upload');
const removeEl = document.getElementById('remove');

const w = document.getElementById('w');
const o = document.getElementById('o');
const col = document.getElementById('col');
const clearBtn = document.getElementById('clear');
const saveBtn = document.getElementById('save');

let baseGuideImg = null;     // preloaded default (head.png)
let customGuideImg = null;   // user-uploaded override
let guideImg = null;         // currently active (custom or base)

let drawing = false;
let lastX = 0, lastY = 0;

// Backing store for strokes (so we can re-render on show/hide/override)
const strokes = []; // each: { color, alpha, width, points:[{x,y},...] }
let currentStroke = null;

/* ------- Helpers ------- */
function setStatus(t, cls='muted'){ statusEl.className = cls; statusEl.textContent = 'Status: ' + t; }

function hexToRgba(hex, alpha){
  const v = hex.replace('#','');
  const r = parseInt(v.substring(0,2),16);
  const g = parseInt(v.substring(2,4),16);
  const b = parseInt(v.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function getPos(e){
  const rect = canvas.getBoundingClientRect();
  const t = ('touches' in e) ? e.touches[0] : ('changedTouches' in e ? e.changedTouches[0] : e);
  return {
    x: (t.clientX - rect.left) * (canvas.width / rect.width),
    y: (t.clientY - rect.top)  * (canvas.height / rect.height)
  };
}

/* ------- Drawing pipeline ------- */
function drawGuide(){
  const img = guideImg;
  if (!img || !showEl.checked) return;
  const max = 640;
  const sx = max / img.width;
  const sy = max / img.height;
  const s = Math.min(sx, sy, 1);
  const w = img.width * s;
  const h = img.height * s;
  const x = (canvas.width - w)/2;
  const y = (canvas.height - h)/2;
  ctx.globalAlpha = 0.45;
  ctx.drawImage(img, x, y, w, h);
  ctx.globalAlpha = 1;
}

function drawStroke(st){
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = st.width;
  ctx.strokeStyle = hexToRgba(st.color, st.alpha);
  ctx.beginPath();
  for (let i=0;i<st.points.length;i++){
    const p = st.points[i];
    if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();
}

function drawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGuide();
  for (const s of strokes) drawStroke(s);
  if (currentStroke) drawStroke(currentStroke);
}

/* ------- Events ------- */
function start(e){
  e.preventDefault();
  drawing = true;
  const p = getPos(e);
  lastX = p.x; lastY = p.y;
  currentStroke = {
    color: col.value,
    alpha: (+o.value)/100,
    width: +w.value,
    points: [{x:p.x,y:p.y}]
  };
  setStatus('drawing…');
}

function move(e){
  if(!drawing) return;
  e.preventDefault();
  const p = getPos(e);
  currentStroke.points.push({x:p.x,y:p.y});
  drawAll();
  lastX = p.x; lastY = p.y;
}

function end(e){
  if(!drawing) return;
  e.preventDefault();
  drawing = false;
  strokes.push(currentStroke);
  currentStroke = null;
  drawAll();
  setStatus('finger/mouse lifted; stroke persists ✓','ok');
}

canvas.addEventListener('pointerdown', start, { passive:false });
canvas.addEventListener('pointermove', move, { passive:false });
canvas.addEventListener('pointerup', end, { passive:false });
canvas.addEventListener('pointercancel', end, { passive:false });
canvas.addEventListener('touchstart', start, { passive:false });
canvas.addEventListener('touchmove', move, { passive:false });
canvas.addEventListener('touchend', end, { passive:false });

w.addEventListener('input', drawAll);
o.addEventListener('input', drawAll);
col.addEventListener('input', drawAll);
clearBtn.addEventListener('click', ()=>{
  strokes.length = 0; currentStroke = null; drawAll(); setStatus('cleared');
});
showEl.addEventListener('change', drawAll);

/* ------- Guide override controls ------- */
uploadEl.addEventListener('change', (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      customGuideImg = img;
      guideImg = customGuideImg || baseGuideImg;
      drawAll();
      setStatus('custom guide loaded ✓','ok');
    };
    img.onerror = () => setStatus('failed to decode uploaded image','warn');
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
});

removeEl.addEventListener('click', ()=>{
  customGuideImg = null;
  guideImg = baseGuideImg;
  drawAll();
  setStatus('reverted to base guide ✓','ok');
});

/* ------- Base preload ------- */
(function preloadBaseGuide(){
  setStatus('loading base guide…');
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = baseGuidePath + '?v=' + Date.now().toString().slice(-6); // cache-buster
  img.onload = () => {
    baseGuideImg = img;
    guideImg = customGuideImg || baseGuideImg;
    drawAll();
    setStatus('base guide loaded ✓','ok');
  };
  img.onerror = () => {
    setStatus('failed to load ' + baseGuidePath, 'warn');
    console.error('Failed base guide path:', baseGuidePath);
  };
})();

/* ------- Save Part (PNG without guide + localStorage) ------- */
function exportStrokesPNG(){
  // Render strokes (no guide) to an offscreen canvas
  const off = document.createElement('canvas');
  off.width = canvas.width; off.height = canvas.height;
  const oc = off.getContext('2d');

  // draw all saved strokes and current stroke (if any)
  function drawStrokeCtx(context, st){
    context.lineCap = 'round';
    context.lineJoin = 'round';
    context.lineWidth = st.width;
    context.strokeStyle = hexToRgba(st.color, st.alpha);
    context.beginPath();
    for (let i=0;i<st.points.length;i++){
      const p = st.points[i];
      if (i===0) context.moveTo(p.x,p.y); else context.lineTo(p.x,p.y);
    }
    context.stroke();
  }
  for (const s of strokes) drawStrokeCtx(oc, s);
  if (currentStroke) drawStrokeCtx(oc, currentStroke);

  return off.toDataURL('image/png'); // transparent background
}

function saveToLocalStorage(dataUrl){
  try{
    const store = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
    store[PART_ID] = dataUrl;
    localStorage.setItem(STORE_KEY, JSON.stringify(store));
    return true;
  } catch(e){
    console.warn('localStorage save failed', e);
    return false;
  }
}

function download(filename, dataUrl){
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

saveBtn.addEventListener('click', ()=>{
  const dataUrl = exportStrokesPNG();
  const ok = saveToLocalStorage(dataUrl);
  download('head-part.png', dataUrl);
  setStatus((ok ? 'saved to localStorage and ' : '') + 'download started ✓','ok');
});

setStatus('ready');
</script>
</body>
</html>
