<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Step 6 — Preview / Animator</title>
<style>
  body{margin:0;background:#0e0f12;color:#e9eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  main{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:8px 0 12px;font-size:18px}
  .row{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
  @media(max-width:1100px){.row{grid-template-columns:1fr}}
  canvas{
    display:block;width:100%;max-width:720px;height:auto;
    background:#0f1219;border:1px solid rgba(255,255,255,.12);border-radius:12px;
    touch-action:none;-ms-touch-action:none;
  }
  .panel{background:#151821;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px}
  .muted{color:#9aa3b2}.ok{color:#5eead4}.warn{color:#fca5a5}
  button,select,input[type="range"]{
    appearance:none;background:#1a1f2b;color:#e9eef7;border:1px solid rgba(255,255,255,.12);
    padding:8px 10px;border-radius:10px;margin-right:8px
  }
  label{display:inline-flex;align-items:center;gap:8px;margin-right:10px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .stack{display:grid;gap:10px}
</style>
</head>
<body>
<main>
  <h1>Step 6 — Preview / Animator</h1>
  <p class="muted">
    Loads art from <code>vbgame.characterArt.v1</code> and rig from <code>vbgame.rig.v1</code>.  
    Animations add temporary offsets (they don’t overwrite your rig).
  </p>

  <div class="row">
    <div class="panel">
      <canvas id="view" width="720" height="720"></canvas>
      <div class="controls">
        <label>Animation
          <select id="anim">
            <option value="idle">Idle sway</option>
            <option value="armsup">Arms up (loop)</option>
            <option value="prep">Prep / bend</option>
            <option value="none">None (rig only)</option>
          </select>
        </label>
        <label>Speed <input id="speed" type="range" min="50" max="200" value="100"></label>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
        <button id="resetPose">Reset pose</button>
        <button id="reloadRig">Reload rig</button>
      </div>
      <div class="controls">
        <button id="center">Center character</button>
        <button id="fit">Fit to canvas</button>
        <span id="status" class="muted">Status: ready</span>
      </div>
    </div>

    <div class="panel">
      <div class="stack">
        <b>Notes</b>
        <ul class="muted">
          <li>If parts are missing, go to Step 4 and save them.</li>
          <li>To change pivots/positions, go back to Step 5 (Rig Editor), save rig, then click <b>Reload rig</b> here.</li>
          <li>This page never edits your rig; it only adds animated offsets during playback.</li>
        </ul>
        <div id="warnings" class="warn"></div>
      </div>
    </div>
  </div>
</main>

<script>
/* -------- Stores & parts -------- */
const STORE_ART = 'vbgame.characterArt.v1';
const STORE_RIG = 'vbgame.rig.v1';
const PARTS = ['torso','head','leftarm','rightarm','shorts','leftleg','rightleg'];
const PARENT = { torso:null, head:'torso', leftarm:'torso', rightarm:'torso', shorts:'torso', leftleg:'shorts', rightleg:'shorts' };

/* -------- DOM -------- */
const cvs = document.getElementById('view');
const ctx = cvs.getContext('2d');
const animEl = document.getElementById('anim');
const speedEl = document.getElementById('speed');
const playBtn = document.getElementById('play');
const pauseBtn = document.getElementById('pause');
const resetPoseBtn = document.getElementById('resetPose');
const reloadRigBtn = document.getElementById('reloadRig');
const centerBtn = document.getElementById('center');
const fitBtn = document.getElementById('fit');
const statusEl = document.getElementById('status');
const warnEl = document.getElementById('warnings');

/* -------- State -------- */
let images = {};   // part -> HTMLImageElement
let baseRig = {};  // part -> {pos, rot, scale, pivot}
let workRig = {};  // a working copy we can reset to base between frames
let playing = true;
let t0 = performance.now();
let centerOffset = { x: cvs.width/2, y: cvs.height/2 };
let globalScale = 1;

function setStatus(t, cls='muted'){ statusEl.className = cls; statusEl.textContent = 'Status: ' + t; }
function warn(msg){ warnEl.textContent = msg || ''; }
function toRad(d){ return d * Math.PI / 180; }

/* -------- Default layout if no rig yet -------- */
function defaultLayout(){
  const c = { x: 0, y: 0 }; // root (torso) will be placed at canvas center via centerOffset
  return {
    torso:{ pos:c, rot:0, scale:1, pivot:{x:0,y:0} },
    head:{ pos:{x:0,y:-180}, rot:0, scale:1, pivot:{x:0,y:0} },
    leftarm:{ pos:{x:-160,y:-40}, rot:0, scale:1, pivot:{x:40,y:40} },
    rightarm:{ pos:{x:160,y:-40}, rot:0, scale:1, pivot:{x:-40,y:40} },
    shorts:{ pos:{x:0,y:140}, rot:0, scale:1, pivot:{x:0,y:0} },
    leftleg:{ pos:{x:-60,y:220}, rot:0, scale:1, pivot:{x:20,y:20} },
    rightleg:{ pos:{x:60,y:220}, rot:0, scale:1, pivot:{x:-20,y:20} }
  };
}

/* -------- Load art -------- */
function loadArt(cb){
  let missing = [];
  let done = 0, total = PARTS.length;
  let store = {};
  try { store = JSON.parse(localStorage.getItem(STORE_ART) || '{}'); } catch {}
  PARTS.forEach(p=>{
    const url = store[p];
    if(!url){ missing.push(p); done++; if(done===total) cb(missing); return; }
    const img = new Image();
    img.onload = ()=>{ images[p] = img; done++; if(done===total) cb(missing); };
    img.onerror = ()=>{ missing.push(p); done++; if(done===total) cb(missing); };
    img.src = url;
  });
}

/* -------- Load rig -------- */
function loadRigFromStorage(){
  let r = null;
  try { r = JSON.parse(localStorage.getItem(STORE_RIG) || 'null'); } catch {}
  if(!r){ r = defaultLayout(); setStatus('no saved rig — using defaults','warn'); }
  baseRig = r;
  copyRig(baseRig, workRig);
}
function copyRig(src, dst){
  for(const p of PARTS){
    const R = src[p];
    if(!dst[p]) dst[p]={pos:{x:0,y:0},rot:0,scale:1,pivot:{x:0,y:0}};
    dst[p].pos = { x: R.pos.x, y: R.pos.y };
    dst[p].rot = R.rot || 0;
    dst[p].scale = R.scale || 1;
    dst[p].pivot = { x: R.pivot.x, y: R.pivot.y };
  }
}

/* -------- Drawing helpers -------- */
function drawImageCentered(img, alpha=1){
  // Fit each art into a reasonable per-part frame
  const max = 300;
  const s = Math.min(max/img.width, max/img.height, 1);
  const w = img.width * s, h = img.height * s;
  const x = -w/2, y = -h/2;
  ctx.globalAlpha = alpha;
  ctx.drawImage(img, x, y, w, h);
  ctx.globalAlpha = 1;
}

function applyTransformStack(part, fn){
  // Build ancestry from root to this part
  const stack = [];
  let cur = part;
  while(cur){
    stack.push(cur);
    cur = PARENT[cur];
  }
  // Apply global transform (center + globalScale) first
  ctx.save();
  ctx.translate(centerOffset.x, centerOffset.y);
  ctx.scale(globalScale, globalScale);

  // Apply each node's transform root-first
  for(let i=stack.length-1; i>=0; i--){
    const id = stack[i];
    const R = workRig[id];
    ctx.translate(R.pos.x, R.pos.y);
    ctx.translate(R.pivot.x, R.pivot.y);
    ctx.rotate(toRad(R.rot||0));
    ctx.scale(R.scale||1, R.scale||1);
    ctx.translate(-R.pivot.x, -R.pivot.y);
  }
  fn();
  ctx.restore();
}

function renderFrame(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const order = ['torso','shorts','leftleg','rightleg','leftarm','rightarm','head']; // simple z-order
  for(const p of order){
    const img = images[p];
    if(!img) continue;
    applyTransformStack(p, ()=> drawImageCentered(img, 1));
  }
}

/* -------- Animations (additive on top of workRig from baseRig each frame) -------- */
function resetWorkPose(){
  copyRig(baseRig, workRig);
}

function animateIdle(t){
  // gentle torso sway + head counter-rotate + arm swing
  const spd = (+speedEl.value)/100; // 0.5x..2x
  const s = Math.sin(t*0.0025*spd);
  const c = Math.cos(t*0.0025*spd);

  workRig.torso.rot += s * 3;            // ±3°
  workRig.head.rot  += -s * 4;           // counter sway
  workRig.leftarm.rot  += c * 5;         // ±5°
  workRig.rightarm.rot += -c * 5;
  workRig.leftleg.rot  += s * 2;         // tiny knee drift
  workRig.rightleg.rot += -s * 2;
}

function animateArmsUp(t){
  const spd = (+speedEl.value)/100;
  const s = (Math.sin(t*0.003*spd)+1)/2;   // 0..1
  const raise = s*80 - 10;                 // -10..70°
  workRig.leftarm.rot  += raise;
  workRig.rightarm.rot += -raise;
  // slight counter head & torso
  workRig.torso.rot += Math.sin(t*0.003*spd)*2;
  workRig.head.rot  += -Math.sin(t*0.003*spd)*2;
}

function animatePrep(t){
  const spd = (+speedEl.value)/100;
  const s = (Math.sin(t*0.004*spd)+1)/2;   // 0..1
  const bend = s*15;                       // up to 15°
  workRig.torso.rot += -bend;
  workRig.leftleg.rot  += bend*1.2;
  workRig.rightleg.rot += bend*1.2;
  workRig.leftarm.rot  += bend*0.5;
  workRig.rightarm.rot += -bend*0.5;
  workRig.shorts.pos.y += s*6 - 3;         // small vertical bob
}

function applyAnimation(t){
  const mode = animEl.value;
  if(mode==='idle') animateIdle(t);
  else if(mode==='armsup') animateArmsUp(t);
  else if(mode==='prep') animatePrep(t);
  // 'none' => no offsets
}

/* -------- Loop -------- */
function tick(now){
  if(playing){
    resetWorkPose();
    applyAnimation(now - t0);
    renderFrame();
  }
  requestAnimationFrame(tick);
}

/* -------- Controls -------- */
playBtn.addEventListener('click', ()=>{ playing=true; setStatus('playing','ok'); });
pauseBtn.addEventListener('click', ()=>{ playing=false; setStatus('paused'); renderFrame(); });
resetPoseBtn.addEventListener('click', ()=>{ resetWorkPose(); renderFrame(); setStatus('pose reset ✓','ok'); });
reloadRigBtn.addEventListener('click', ()=>{ loadRigFromStorage(); setStatus('rig reloaded ✓','ok'); });
animEl.addEventListener('change', ()=> setStatus('mode: '+animEl.value));
speedEl.addEventListener('input', ()=> setStatus('speed: '+(+speedEl.value/100).toFixed(2)+'x'));

/* view helpers */
centerBtn.addEventListener('click', ()=>{ centerOffset={x:cvs.width/2,y:cvs.height/2}; renderFrame(); setStatus('centered ✓','ok'); });
fitBtn.addEventListener('click', ()=>{
  // naive fit: scale so torso->legs roughly fills height
  globalScale = 1.0; // reset
  const want = cvs.height*0.75;
  // estimate stack height using rig offsets; this is rough but fine
  const est = 600;
  globalScale = Math.min(1.4, Math.max(0.6, want/est));
  renderFrame(); setStatus('fit view ✓','ok');
});

/* -------- Boot -------- */
(function init(){
  // load art
  loadArt((missing)=>{
    if(missing.length){
      warn('Missing art for: ' + missing.join(', ') + '. Go to Step 4 and save those parts.');
    } else warn('');

    // load rig
    loadRigFromStorage();

    // start loop
    t0 = performance.now();
    requestAnimationFrame(tick);
    setStatus('ready');
  });
})();
</script>
</body>
</html>
