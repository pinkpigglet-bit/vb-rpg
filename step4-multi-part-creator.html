<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Step 4 — Multi-Part Creator (Vanilla Canvas)</title>
<style>
  body{margin:0;background:#0e0f12;color:#e9eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  main{max-width:1000px;margin:0 auto;padding:16px}
  h1{margin:8px 0 12px;font-size:18px}
  .row{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  @media(max-width:1000px){.row{grid-template-columns:1fr}}
  canvas{
    display:block;width:100%;max-width:720px;height:auto;
    background:#0f1219;border:1px solid rgba(255,255,255,.12);border-radius:12px;
    touch-action:none;-ms-touch-action:none;
  }
  .panel{background:#151821;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px}
  .muted{color:#9aa3b2}
  .ok{color:#5eead4}.warn{color:#fca5a5}
  button,input[type="range"],input[type="color"],input[type="checkbox"],input[type="file"],select{
    appearance:none;background:#1a1f2b;color:#e9eef7;border:1px solid rgba(255,255,255,.12);
    padding:8px 10px;border-radius:10px;margin-right:8px
  }
  label{display:inline-flex;align-items:center;gap:8px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
</style>
</head>
<body>
<main>
  <h1>Step 4 — Multi-Part Creator (Vanilla Canvas)</h1>
  <p class="muted">
    Choose a part, draw over the base template, optionally upload your own guide (overrides base), and <b>Save Part</b>.
    Saved drawings are downloaded as transparent PNG and stored locally in <code>localStorage</code>.
  </p>

  <div class="panel" style="margin-bottom:12px;display:flex;flex-wrap:wrap;align-items:center;gap:8px">
    <label>Part
      <select id="part">
        <option value="head">Head</option>
        <option value="torso">Torso</option>
        <option value="leftarm">Left Arm</option>
        <option value="rightarm">Right Arm</option>
        <option value="shorts">Shorts</option>
        <option value="leftleg">Left Leg</option>
        <option value="rightleg">Right Leg</option>
      </select>
    </label>
    <span id="status" class="muted">Status: ready</span>
  </div>

  <div class="row">
    <div class="panel">
      <canvas id="c" width="720" height="720"></canvas>

      <div class="controls">
        <label>Brush <input id="w" type="range" min="1" max="40" value="8"></label>
        <label>Opacity <input id="o" type="range" min="10" max="100" value="100"></label>
        <label>Color <input id="col" type="color" value="#60a5fa"></label>
        <label><input id="show" type="checkbox" checked> Show guide</label>
        <input id="upload" type="file" accept="image/*">
        <button id="remove">Remove guide</button>
        <button id="clear">Clear</button>
        <button id="save">Save Part</button>
        <button id="reset">Reset Part</button>

      </div>
    </div>

    <div class="panel">
      <p class="muted">Base guide path pattern: <code>assets/guides/&lt;part&gt;.png</code></p>
      <ul class="muted">
        <li>Switch parts with the dropdown — base PNG loads automatically.</li>
        <li>Upload overrides the base; Remove reverts to base.</li>
        <li>Draw lines and lift finger/mouse — strokes persist.</li>
        <li><b>Save Part</b> downloads <code>&lt;part&gt;-part.png</code> and stores it to <code>localStorage</code> under <code>vbgame.characterArt.v1.&lt;part&gt;</code>.</li>
        <li>If a saved image exists for a part, it loads as a locked layer so you can continue.</li>
      </ul>
    </div>
  </div>
</main>

<script>
/* ------- Config & constants ------- */
const STORE_KEY = 'vbgame.characterArt.v1';
const PARTS = ['head','torso','leftarm','rightarm','shorts','leftleg','rightleg'];

/* ------- DOM refs ------- */
const partEl = document.getElementById('part');
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const statusEl = document.getElementById('status');
const showEl = document.getElementById('show');
const uploadEl = document.getElementById('upload');
const removeEl = document.getElementById('remove');
const clearBtn = document.getElementById('clear');
const saveBtn = document.getElementById('save');
const resetBtn = document.getElementById('reset');
const w = document.getElementById('w');
const o = document.getElementById('o');
const col = document.getElementById('col');




/* ------- Guide & layers state ------- */
let currentPart = partEl.value;

let baseGuideImg = null;     // per-part base image
let customGuideImg = null;   // per-part uploaded override (not persisted across parts)
let guideImg = null;         // active guide = custom || base

let savedArtImg = null;      // previously saved drawing for this part (from localStorage), locked layer

/* Drawing state */
let drawing = false;
let lastX = 0, lastY = 0;
const strokes = [];          // current-session strokes (not persisted until Save)
let currentStroke = null;

/* ------- Helpers ------- */
function setStatus(t, cls='muted'){ statusEl.className = cls; statusEl.textContent = 'Status: ' + t; }
function cacheBust(url){ return url + (url.includes('?')?'&':'?') + 'v=' + Date.now().toString().slice(-6); }

function hexToRgba(hex, alpha){
  const v = hex.replace('#','');
  const r = parseInt(v.substring(0,2),16);
  const g = parseInt(v.substring(2,4),16);
  const b = parseInt(v.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  const t = ('touches' in e) ? e.touches[0] : ('changedTouches' in e ? e.changedTouches[0] : e);
  return {
    x: (t.clientX - rect.left) * (canvas.width / rect.width),
    y: (t.clientY - rect.top)  * (canvas.height / rect.height)
  };
}

/* ------- Drawing ------- */
function drawImageCentered(img, alpha=1){
  const max = 640;
  const s = Math.min(max / img.width, max / img.height, 1);
  const w = img.width * s;
  const h = img.height * s;
  const x = (canvas.width - w)/2;
  const y = (canvas.height - h)/2;
  ctx.globalAlpha = alpha;
  ctx.drawImage(img, x, y, w, h);
  ctx.globalAlpha = 1;
}

function drawGuide(){
  if (!guideImg || !showEl.checked) return;
  drawImageCentered(guideImg, 0.45);
}
function drawSavedArt(){
  if (!savedArtImg) return;
  // Draw saved art fully (acts like a background layer you can continue over)
  drawImageCentered(savedArtImg, 1);
}
function drawStroke(st){
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = st.width;
  ctx.strokeStyle = hexToRgba(st.color, st.alpha);
  ctx.beginPath();
  for (let i=0;i<st.points.length;i++){
    const p = st.points[i];
    if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();
}
function drawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGuide();      // backmost
  drawSavedArt();   // then any previously saved drawing
  for (const s of strokes) drawStroke(s);
  if (currentStroke) drawStroke(currentStroke);
}

/* ------- Input events ------- */
function start(e){
  e.preventDefault();
  drawing = true;
  const p = getPos(e);
  lastX = p.x; lastY = p.y;
  currentStroke = {
    color: col.value,
    alpha: (+o.value)/100,
    width: +w.value,
    points: [{x:p.x,y:p.y}]
  };
  setStatus('drawing…');
}
function move(e){
  if(!drawing) return;
  e.preventDefault();
  const p = getPos(e);
  currentStroke.points.push({x:p.x,y:p.y});
  drawAll();
  lastX = p.x; lastY = p.y;
}
function end(e){
  if(!drawing) return;
  e.preventDefault();
  drawing = false;
  strokes.push(currentStroke);
  currentStroke = null;
  drawAll();
  setStatus('stroke committed ✓','ok');
}

canvas.addEventListener('pointerdown', start, { passive:false });
canvas.addEventListener('pointermove', move, { passive:false });
canvas.addEventListener('pointerup', end, { passive:false });
canvas.addEventListener('pointercancel', end, { passive:false });
canvas.addEventListener('touchstart', start, { passive:false });
canvas.addEventListener('touchmove', move, { passive:false });
canvas.addEventListener('touchend', end, { passive:false });

w.addEventListener('input', drawAll);
o.addEventListener('input', drawAll);
col.addEventListener('input', drawAll);
clearBtn.addEventListener('click', ()=>{
  strokes.length = 0; currentStroke = null; drawAll(); setStatus('cleared');
});
showEl.addEventListener('change', drawAll);

/* ------- Save (no guide; includes savedArt + new strokes) ------- */
function exportPNGWithoutGuide(){
  const off = document.createElement('canvas');
  off.width = canvas.width; off.height = canvas.height;
  const oc = off.getContext('2d');

  // 1) draw previously saved art if present
  if (savedArtImg){
    const max = 640;
    const s = Math.min(max / savedArtImg.width, max / savedArtImg.height, 1);
    const w = savedArtImg.width * s;
    const h = savedArtImg.height * s;
    const x = (off.width - w)/2;
    const y = (off.height - h)/2;
    oc.drawImage(savedArtImg, x, y, w, h);
  }

  // 2) draw new strokes
  function drawStrokeCtx(context, st){
    context.lineCap = 'round';
    context.lineJoin = 'round';
    context.lineWidth = st.width;
    context.strokeStyle = hexToRgba(st.color, st.alpha);
    context.beginPath();
    for (let i=0;i<st.points.length;i++){
      const p = st.points[i];
      if (i===0) context.moveTo(p.x,p.y); else context.lineTo(p.x,p.y);
    }
    context.stroke();
  }
  for (const s of strokes) drawStrokeCtx(oc, s);
  if (currentStroke) drawStrokeCtx(oc, currentStroke);

  return off.toDataURL('image/png'); // transparent background
}

function saveToLocalStorage(partId, dataUrl){
  try{
    const store = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
    store[partId] = dataUrl;
    localStorage.setItem(STORE_KEY, JSON.stringify(store));
    return true;
  } catch(e){
    console.warn('localStorage save failed', e);
    return false;
  }
}

function download(filename, dataUrl){
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

saveBtn.addEventListener('click', ()=>{
  const dataUrl = exportPNGWithoutGuide();
  const ok = saveToLocalStorage(currentPart, dataUrl);
  download(`${currentPart}-part.png`, dataUrl);
  setStatus((ok ? `saved ${currentPart} locally and ` : '') + 'download started ✓','ok');
  // After saving, refresh the savedArt layer so continued drawing builds on the saved PNG
  loadSavedArtLayer(currentPart, () => drawAll());
});

resetBtn.addEventListener('click', () => {
  try {
    const store = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
    delete store[currentPart];
    localStorage.setItem(STORE_KEY, JSON.stringify(store));
  } catch(e) {
    console.warn('localStorage reset failed', e);
  }
  savedArtImg = null;      // remove the locked saved layer
  strokes.length = 0;      // clear current session strokes
  currentStroke = null;
  drawAll();
  setStatus(`cleared saved ${currentPart} drawing ✓`, 'ok');
});

/* ------- Guide override ------- */
uploadEl.addEventListener('change', (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      customGuideImg = img;
      guideImg = customGuideImg || baseGuideImg;
      drawAll();
      setStatus('custom guide loaded ✓','ok');
    };
    img.onerror = () => setStatus('failed to decode uploaded image','warn');
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
});

removeEl.addEventListener('click', ()=>{
  customGuideImg = null;
  guideImg = baseGuideImg;
  drawAll();
  setStatus('reverted to base guide ✓','ok');
});

/* ------- Loaders per part ------- */
function loadBaseGuide(partId, cb){
  baseGuideImg = null;
  guideImg = null;
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = cacheBust(`assets/guides/${partId}.png`);
  img.onload = () => {
    baseGuideImg = img;
    guideImg = customGuideImg || baseGuideImg;
    cb && cb();
  };
  img.onerror = () => { setStatus(`failed to load base guide for ${partId}`, 'warn'); cb && cb(); };
}

function loadSavedArtLayer(partId, cb){
  savedArtImg = null;
  try{
    const store = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
    const url = store[partId];
    if (!url) { cb && cb(); return; }
    const img = new Image();
    img.onload = () => { savedArtImg = img; cb && cb(); };
    img.onerror = () => { setStatus(`could not decode saved ${partId} image`, 'warn'); cb && cb(); };
    img.src = url;
  }catch(e){
    console.warn('localStorage parse error', e);
    cb && cb();
  }
}

/* ------- Part switch ------- */
function resetSessionStrokes(){
  strokes.length = 0;
  currentStroke = null;
}
function loadPart(partId){
  setStatus(`loading ${partId}…`);
  currentPart = partId;
  customGuideImg = null; // per-part custom overrides are not persisted
  resetSessionStrokes();

  // Load base, then saved art, then render
  loadBaseGuide(partId, ()=>{
    loadSavedArtLayer(partId, ()=>{
      drawAll();
      setStatus(`${partId} ready ✓`, 'ok');
    });
  });
}

/* ------- Boot ------- */
partEl.addEventListener('change', ()=> loadPart(partEl.value));
loadPart(currentPart);
setStatus('ready');
</script>
</body>
</html>
