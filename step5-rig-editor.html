<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Step 5 — Rig Editor</title>
<style>
  body{margin:0;background:#0e0f12;color:#e9eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  main{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:8px 0 12px;font-size:18px}
  .row{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
  @media(max-width:1100px){.row{grid-template-columns:1fr}}
  canvas{
    display:block;width:100%;max-width:720px;height:auto;
    background:#0f1219;border:1px solid rgba(255,255,255,.12);border-radius:12px;
    touch-action:none;-ms-touch-action:none;
  }
  .panel{background:#151821;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px}
  .muted{color:#9aa3b2}.ok{color:#5eead4}.warn{color:#fca5a5}
  button,input[type="range"],input[type="color"],select,input[type="checkbox"]{
    appearance:none;background:#1a1f2b;color:#e9eef7;border:1px solid rgba(255,255,255,.12);
    padding:8px 10px;border-radius:10px;margin-right:8px
  }
  input[type="checkbox"]{appearance:auto;cursor:pointer;width:18px;height:18px}
  label{display:inline-flex;align-items:center;gap:8px;margin-right:10px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .stack{display:grid;gap:10px}
  .row2{display:flex;flex-wrap:wrap;gap:10px}
  code{background:#0b0f16;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.06)}
  .chip{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#0f141f;cursor:pointer}
  .chip.active{outline:2px solid rgba(94,234,212,.5)}
</style>
</head>
<body>
<main>
  <h1>Step 5 — Rig Editor</h1>
  <p class="muted">Place pivots, move parts, test rotations, and save a rig. Uses saved PNGs from <code>vbgame.characterArt.v1</code>.</p>

  <div class="row">
    <div class="panel">
      <canvas id="rig" width="720" height="720"></canvas>
      <div class="controls">
        <label>Part
          <select id="part">
            <option value="torso">Torso</option>
            <option value="head">Head</option>
            <option value="leftarm">Left Arm</option>
            <option value="rightarm">Right Arm</option>
            <option value="shorts">Shorts</option>
            <option value="leftleg">Left Leg</option>
            <option value="rightleg">Right Leg</option>
          </select>
        </label>
        <label><input id="editPivot" type="checkbox"> Edit pivot</label>
        <label>Rotate <input id="rot" type="range" min="-180" max="180" value="0"></label>
        <label>Scale <input id="scale" type="range" min="50" max="150" value="100"></label>
        <button id="resetPose">Reset pose</button>
      </div>
      <div class="controls">
        <button id="saveRig">Save Rig</button>
        <button id="loadRig">Load Rig</button>
        <button id="resetRig">Reset Rig</button>
        <span id="status" class="muted">Status: ready</span>
      </div>
    </div>

    <div class="panel">
      <div class="stack">
        <div><b>Hierarchy</b> (fixed for now)</div>
        <div class="row2">
          <span class="chip">torso</span> →
          <span class="chip">head</span>,
          <span class="chip">leftarm</span>,
          <span class="chip">rightarm</span>,
          <span class="chip">shorts</span> →
          <span class="chip">leftleg</span>,
          <span class="chip">rightleg</span>
        </div>
        <div class="muted">We’ll make this editable later. For now, use these connections.</div>

        <div><b>Tips</b></div>
        <ul class="muted">
          <li>Drag to move the selected part (relative to its parent).</li>
          <li>Enable <b>Edit pivot</b>, then drag the little crosshair to set rotation pivot.</li>
          <li>Use <b>Rotate</b> to test rotation around the pivot.</li>
          <li><b>Save Rig</b> stores all part transforms/pivots in <code>vbgame.rig.v1</code>.</li>
        </ul>

        <div id="warnings" class="warn"></div>
      </div>
    </div>
  </div>
</main>

<script>
/* ---------- Config ---------- */
const STORE_ART = 'vbgame.characterArt.v1';  // PNG dataURLs per part
const STORE_RIG = 'vbgame.rig.v1';          // rig JSON
const PARTS = ['torso','head','leftarm','rightarm','shorts','leftleg','rightleg'];
// Fixed parenting for Step 5
const PARENT = {
  torso: null,
  head: 'torso',
  leftarm: 'torso',
  rightarm: 'torso',
  shorts: 'torso',
  leftleg: 'shorts',
  rightleg: 'shorts'
};

/* ---------- DOM ---------- */
const canvas = document.getElementById('rig');
const ctx = canvas.getContext('2d');
const partEl = document.getElementById('part');
const editPivotEl = document.getElementById('editPivot');
const rotEl = document.getElementById('rot');
const scaleEl = document.getElementById('scale');
const resetPoseBtn = document.getElementById('resetPose');
const saveRigBtn = document.getElementById('saveRig');
const loadRigBtn = document.getElementById('loadRig');
const resetRigBtn = document.getElementById('resetRig');
const statusEl = document.getElementById('status');
const warningsEl = document.getElementById('warnings');

/* ---------- State ---------- */
let selected = partEl.value;
const images = {}; // part -> HTMLImageElement
const rig = {};    // part -> { pos:{x,y}, rot, scale, pivot:{x,y} }
let dragging = false;
let dragMode = 'part'; // 'part' or 'pivot'
let last = {x:0,y:0};

/* ---------- Helpers ---------- */
function setStatus(t, cls='muted'){ statusEl.className = cls; statusEl.textContent = 'Status: ' + t; }
function warn(msg){ warningsEl.textContent = msg || ''; }
function center(){ return { x: canvas.width/2, y: canvas.height/2 }; }
function toRad(deg){ return deg * Math.PI / 180; }
function getMouse(e){
  const r = canvas.getBoundingClientRect();
  const t = ('touches' in e) ? e.touches[0] : ('changedTouches' in e ? e.changedTouches[0] : e);
  return { x: (t.clientX - r.left) * (canvas.width/r.width), y: (t.clientY - r.top) * (canvas.height/r.height) };
}

/* ---------- Default rig layout (relative to parent) ---------- */
function defaultLayout(){
  const c = center();
  rig.torso = { pos:{x:c.x, y:c.y}, rot:0, scale:1, pivot:{x:0, y:0} };
  rig.head  = { pos:{x:0, y:-180}, rot:0, scale:1, pivot:{x:0, y:0} };
  rig.leftarm  = { pos:{x:-160, y:-40}, rot:0, scale:1, pivot:{x:40, y:40} };
  rig.rightarm = { pos:{x:160, y:-40}, rot:0, scale:1, pivot:{x:-40, y:40} };
  rig.shorts = { pos:{x:0, y:140}, rot:0, scale:1, pivot:{x:0, y:0} };
  rig.leftleg  = { pos:{x:-60, y:220}, rot:0, scale:1, pivot:{x:20, y:20} };
  rig.rightleg = { pos:{x:60,  y:220}, rot:0, scale:1, pivot:{x:-20, y:20} };
}

/* ---------- Load saved art ---------- */
function loadArt(cb){
  let missing = [];
  let loaded = 0;
  let total = PARTS.length;
  let store = {};
  try { store = JSON.parse(localStorage.getItem(STORE_ART) || '{}'); } catch {}
  PARTS.forEach(p=>{
    const url = store[p];
    if(!url){ missing.push(p); loaded++; if(loaded===total) cb(missing); return; }
    const img = new Image();
    img.onload = ()=>{ images[p] = img; loaded++; if(loaded===total) cb(missing); };
    img.onerror = ()=>{ missing.push(p); loaded++; if(loaded===total) cb(missing); };
    img.src = url;
  });
}

/* ---------- Save/Load rig ---------- */
function saveRig(){
  try{
    localStorage.setItem(STORE_RIG, JSON.stringify(rig));
    setStatus('rig saved ✓','ok');
  }catch(e){
    setStatus('rig save failed','warn');
  }
}
function loadRig(){
  try{
    const data = JSON.parse(localStorage.getItem(STORE_RIG) || 'null');
    if(!data){ setStatus('no rig saved yet','warn'); return; }
    Object.assign(rig, data);
    syncUIFromSelected();
    setStatus('rig loaded ✓','ok');
    render();
  }catch(e){
    setStatus('rig load failed','warn');
  }
}
function resetRig(){
  defaultLayout();
  syncUIFromSelected();
  render();
  setStatus('rig reset to defaults','ok');
}

/* ---------- Transform stack & rendering ---------- */
function withTransform(part, fn){
  const R = rig[part];
  ctx.save();
  // Apply parent transform first (recursive)
  const parent = PARENT[part];
  if(parent){
    withTransform(parent, ()=>{ /* inside parent space */ });
    // after returning, parent's transform is active on context
  }
  // If parent exists, we need to re-apply only once — but the recursion above
  // already pushed + applied it. Because we nested save inside, we need a trick:
  // Instead, compute transforms iteratively.
  ctx.restore();
  // Use iterative approach:
  const stack = [];
  let cur = part;
  while(cur){
    stack.push(cur);
    cur = PARENT[cur];
  }
  // Now apply root-first
  ctx.save();
  for(let i=stack.length-1; i>=0; i--){
    const id = stack[i];
    const T = rig[id];
    // Translate to node position
    ctx.translate(T.pos.x, T.pos.y);
    // Apply rotation/scale around pivot
    ctx.translate(T.pivot.x, T.pivot.y);
    ctx.rotate(toRad(T.rot || 0));
    ctx.scale(T.scale || 1, T.scale || 1);
    ctx.translate(-T.pivot.x, -T.pivot.y);
  }
  fn();
  ctx.restore();
}

function drawImageFor(part, alpha=1){
  const img = images[part];
  if(!img) return;
  // Draw centered on its local origin (0,0) with fit
  const max = 300; // per-part local fit size for preview
  const s = Math.min(max/img.width, max/img.height, 1);
  const w = img.width * s, h = img.height * s;
  const x = -w/2, y = -h/2; // local origin at image center
  ctx.globalAlpha = alpha;
  ctx.drawImage(img, x, y, w, h);
  ctx.globalAlpha = 1;
}

function drawPivotCross(part){
  const T = rig[part];
  withTransform(part, ()=>{
    // pivot in local coords is T.pivot; we’ve already transformed so draw at its location
    ctx.save();
    ctx.translate(T.pivot.x, T.pivot.y);
    ctx.strokeStyle = '#5eead4';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10,0); ctx.lineTo(10,0);
    ctx.moveTo(0,-10); ctx.lineTo(0,10);
    ctx.stroke();
    ctx.restore();
  });
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Draw in hierarchy order: torso(root) → head, arms, shorts → legs
  const order = ['torso','head','leftarm','rightarm','shorts','leftleg','rightleg'];
  order.forEach(p=>{
    withTransform(p, ()=>{
      drawImageFor(p, 1);
    });
  });
  // Selected highlight & pivot cross
  drawPivotCross(selected);
  // Selected outline
  withTransform(selected, ()=>{
    ctx.save();
    ctx.strokeStyle = 'rgba(96,165,250,.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.strokeRect(-160,-160,320,320); // rough handle box around local origin
    ctx.restore();
  });
}

/* ---------- Interaction ---------- */
function pickDragMode(){ dragMode = editPivotEl.checked ? 'pivot' : 'part'; }

canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  dragging = true;
  last = getMouse(e);
});
canvas.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  e.preventDefault();
  const cur = getMouse(e);
  const dx = cur.x - last.x, dy = cur.y - last.y;
  const R = rig[selected];
  if(dragMode === 'part'){
    // Move part in its parent space
    R.pos.x += dx;
    R.pos.y += dy;
  } else {
    // Move pivot in local space (approximate: same dx/dy)
    R.pivot.x += dx;
    R.pivot.y += dy;
  }
  last = cur;
  render();
});
['pointerup','pointercancel','touchend','touchcancel'].forEach(ev=>{
  canvas.addEventListener(ev, ()=>{ dragging=false; });
});

/* ---------- UI sync ---------- */
function syncUIFromSelected(){
  const R = rig[selected];
  rotEl.value = (R.rot||0);
  scaleEl.value = Math.round((R.scale||1)*100);
}
partEl.addEventListener('change', ()=>{
  selected = partEl.value;
  syncUIFromSelected();
  render();
});
editPivotEl.addEventListener('change', ()=>{ pickDragMode(); setStatus(editPivotEl.checked?'pivot mode':'move mode'); });

rotEl.addEventListener('input', ()=>{
  rig[selected].rot = +rotEl.value;
  render();
});
scaleEl.addEventListener('input', ()=>{
  rig[selected].scale = (+scaleEl.value)/100;
  render();
});

resetPoseBtn.addEventListener('click', ()=>{
  // Only reset rotations/scales (keep positions/pivots)
  PARTS.forEach(p=>{ rig[p].rot=0; rig[p].scale=1; });
  syncUIFromSelected();
  render();
  setStatus('pose reset ✓','ok');
});

/* ---------- Rig buttons ---------- */
saveRigBtn.addEventListener('click', saveRig);
loadRigBtn.addEventListener('click', ()=>{ loadRig(); });
resetRigBtn.addEventListener('click', ()=>{ resetRig(); });

/* ---------- Boot ---------- */
(function init(){
  // defaults
  defaultLayout();

  // load saved rig if exists
  try{
    const data = JSON.parse(localStorage.getItem(STORE_RIG) || 'null');
    if(data){ Object.assign(rig, data); }
  }catch{}

  // load art
  loadArt((missing)=>{
    if(missing.length){
      warn('Missing art for: ' + missing.join(', ') + '. Go back to Step 4 to save those parts.');
    } else { warn(''); }
    syncUIFromSelected();
    render();
  });
})();
</script>
</body>
</html>
